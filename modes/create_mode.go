package modes

import (
	"fmt"
	"path/filepath"
	"strings"

	"github.com/charmbracelet/bubbles/textinput"
	tea "github.com/charmbracelet/bubbletea"

	"github.com/jkeresman01/tsm/tmux"
	"github.com/jkeresman01/tsm/utils"
)

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			CreateMode handles creating new tmux sessions from project directories.
//
//		@Description	Provides fuzzy search and keyboard navigation for directory selection
//
// ///////////////////////////////////////////////////////////////////////////////////////////
type CreateMode struct {
	dirs     []string
	filtered []string
	cursor   int
	input    textinput.Model
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			NewCreateMode creates a new CreateMode instance.
//
//		@Param			dirs	[]string	List of available project directories
//
//		@Return			*CreateMode	Initialized CreateMode
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func NewCreateMode(dirs []string) *CreateMode {
	return &CreateMode{
		dirs:     dirs,
		filtered: dirs,
		input:    newSearchInput(),
	}
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			Update processes input messages and updates the mode state.
//
//		@Param			msg		tea.Msg			Input message
//
//		@Return			ModeStrategy	Updated mode state
//		@Return			tea.Cmd			Optional command
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) Update(msg tea.Msg) (ModeStrategy, tea.Cmd) {
	if key, ok := msg.(tea.KeyMsg); ok {
		if next, done := m.handleKey(key); done {
			return next, nil
		}
	}
	cmd := m.updateQuery(msg)
	m.applyFilter()
	m.clampCursor()
	return m, cmd
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			View renders the mode's UI.
//
//		@Return			string	Rendered view with directory list
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) View() string {
	var b strings.Builder
	b.WriteString(m.renderSearchBar())
	if len(m.filtered) == 0 {
		return b.String() + m.renderEmptyState()
	}
	m.renderDirectoryList(&b)
	b.WriteString(m.renderCount())
	return b.String()
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			ModeName returns the display name of this mode.
//
//		@Return			string	"CREATE"
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) ModeName() string { return "CREATE" }

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	@Brief			Reset clears the mode state.
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) Reset() {}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			GetCurrentSession returns empty string (no session selected in create mode).
//
//		@Return			string	Empty string
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) GetCurrentSession() string { return "" }

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			newSearchInput creates a configured text input for search.
//
//		@Return			textinput.Model	Configured input field
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func newSearchInput() textinput.Model {
	ti := textinput.New()
	ti.Placeholder = "Search directories..."
	ti.Focus()
	ti.Prompt = ""
	ti.Width = 30
	return ti
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			handleKey processes keyboard input.
//
//		@Param			k		tea.KeyMsg		Keyboard message
//
//		@Return			ModeStrategy	Next mode (if changed)
//		@Return			bool			Whether key was handled
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) handleKey(k tea.KeyMsg) (ModeStrategy, bool) {
	switch k.String() {
	case "up", "k":
		m.moveCursor(-1)
	case "down", "j":
		m.moveCursor(1)
	case "enter":
		return m.confirmSelection(), true
	}
	return nil, false
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			GetIcon returns the mode's icon.
//
//		@Return			string	Nerd font icon
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) GetIcon() string {
	return "Û∞êï"
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			GetFooterText returns the help text for the footer.
//
//		@Return			string	Keybinding help text
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) GetFooterText() string {
	return "‚Üë‚Üì navigate ‚Ä¢ ‚Üµ create ‚Ä¢ ‚á• cycle ‚Ä¢ ? help ‚Ä¢ q quit"
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			updateQuery updates the search input field.
//
//		@Param			msg		tea.Msg		Input message
//
//		@Return			tea.Cmd	Command from input update
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) updateQuery(msg tea.Msg) tea.Cmd {
	var cmd tea.Cmd
	m.input, cmd = m.input.Update(msg)
	return cmd
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	@Brief			applyFilter filters directories based on search query.
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) applyFilter() {
	m.filtered = utils.FuzzyFilter(m.dirs, m.query())
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			moveCursor moves the cursor by delta positions.
//
//		@Param			delta	int	Number of positions to move (negative for up)
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) moveCursor(delta int) {
	if len(m.filtered) == 0 {
		m.cursor = 0
		return
	}
	m.cursor += delta
	m.clampCursor()
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	@Brief			clampCursor ensures cursor stays within valid range.
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) clampCursor() {
	n := len(m.filtered)
	if n == 0 {
		m.cursor = 0
		return
	}
	if m.cursor < 0 {
		m.cursor = 0
	} else if m.cursor >= n {
		m.cursor = n - 1
	}
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			confirmSelection creates a tmux session from the selected directory.
//
//		@Return			ModeStrategy	SwitchMode with updated session list
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) confirmSelection() ModeStrategy {
	if !m.hasSelection() {
		return m
	}
	dir := m.selectedDir()
	name := filepath.Base(dir)
	tmux.CreateSession(name, dir)
	sessions, _ := tmux.ListSessions()
	return NewSwitchMode(sessions)
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			hasSelection returns whether a valid directory is selected.
//
//		@Return			bool	True if a directory is selected
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) hasSelection() bool {
	return len(m.filtered) > 0 && m.cursor >= 0 && m.cursor < len(m.filtered)
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			selectedDir returns the currently selected directory.
//
//		@Return			string	Selected directory path
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) selectedDir() string {
	return m.filtered[m.cursor]
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			rowPrefix returns the prefix for a list row.
//
//		@Param			i		int		Row index
//
//		@Return			string	Prefix ("‚ñ∂ " for selected, "  " for others)
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) rowPrefix(i int) string {
	if i == m.cursor {
		return "‚ñ∂ "
	}
	return "  "
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			query returns the current search query.
//
//		@Return			string	Search query text
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) query() string {
	return m.input.Value()
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			renderSearchBar renders the search input bar.
//
//		@Return			string	Rendered search bar
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) renderSearchBar() string {
	return "üîç " + m.input.View() + "\n\n"
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			renderEmptyState renders the empty state message.
//
//		@Return			string	Empty state message
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) renderEmptyState() string {
	return "  No directories found\n  Tip: Add search paths in ~/.config/tsm/config.json\n"
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			renderDirectoryList renders the list of directories.
//
//		@Param			b	*strings.Builder	String builder to append to
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) renderDirectoryList(b *strings.Builder) {
	q := m.query()
	for i, d := range m.filtered {
		m.renderDirectoryRow(b, i, d, q)
	}
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			renderDirectoryRow renders a single directory row.
//
//		@Param			b	*strings.Builder	String builder to append to
//		@Param			i	int					Row index
//		@Param			d	string				Directory path
//		@Param			q	string				Search query for highlighting
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) renderDirectoryRow(b *strings.Builder, i int, d, q string) {
	icon := "Û∞âã "
	prefix := m.rowPrefix(i)
	b.WriteString(prefix)
	b.WriteString(icon)
	b.WriteString(utils.HighlightMatches(filepath.Base(d), q))
	if i == m.cursor {
		b.WriteString("  Û∞Ñæ")
	}
	b.WriteByte('\n')
	if i == m.cursor {
		b.WriteString("    Û∞âñ " + d + "\n")
	}
}

// ///////////////////////////////////////////////////////////////////////////////////////////
//
//	 @Brief			renderCount renders the directory count footer.
//
//		@Return			string	Count message
//
// ///////////////////////////////////////////////////////////////////////////////////////////
func (m *CreateMode) renderCount() string {
	return fmt.Sprintf("\n  %d director(ies)", len(m.filtered))
}
